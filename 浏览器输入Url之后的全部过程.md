# 浏览器输入Url之后的全部过程

### 一. DNS域名解析

------

我们在浏览器输入一段网址, 其实就是要向服务器请求我们想要的页面内容, 所有的浏览器首先要确认的是域名所对应的服务器在哪里, 将域名解析成对应的服务器IP地址这项工作, 是由DNS服务器来完成的

客户端收到你输入的域名地址后, 它首先去找本地的hosts文件, 检查在该文件中是否有相应的域名, ip对应关系, 如果有, 则向其ip地址发送请求, 如果没有, 再去找DNS服务器

由于本地DNS服务器没有缓存不能直接将域名转换为IP地址, 需要采用递归或者迭代查询的方式一次向`根域名服务器` => `顶级域服务器` => `权威域名服务器` 发起查询请求, 直到找到一个或者一组IP地址,返回给浏览器

<img src="C:\Users\weiyafei\Pictures\Saved Pictures\DNS服务器层次结构.png" style="zoom:50%;" />

上图是 DNS服务器层次结构(图片来源:https://www.xuecaijie.com/it/157.html)

<img src="C:\Users\weiyafei\Pictures\Saved Pictures\DNS查询过程.png" style="zoom: 80%;" />

上图解析url的顺序看起来是这样的

​	浏览器客户端向本地DNS服务器发送一个含有域名`www.cnblogs.com`的DNS查询报文, 本地DNS服务器把查询报文转发到根DNS服务器, 根DNS服务器注意到其com后缀, 于是向本地DNS服务器返回comDNS服务器的ip地址, 本地DNS服务器再次向comDNS服务器发送查询请求, comDNS服务器注意到其`www.cnblogs.com`后缀并用负责该域名的权威DNS服务器的ip地址作为回应. 最后, 本地DNS服务器将含有`www.cnblogs.com`的ip地址的响应报文发送给客户端

> 从客户端到本地DNS服务器查询属于递归查询,  这个过程中任何一步查询都会结束查询流程
>
> DNS服务器之间的交互属于迭代查询
>
> 正常情况下, 本地DNS服务器的缓存中已有comDNS服务器的地址, 因此请求根域名服务器这一步不是必须的

### 二. 建立TCP链接(如果只有两次握手, 1,服务器无法判断客户端是否由接受信息的能力, 2,如果网络堵塞,客户端向服务端发送连接没有连接成功,于是客户端第二次发送连接,连接成功, 然后第一次发送的连接服务端收到了, 成功建立连接,这个连接在服务器就一直等待客户端的数据交互,但是客户端以为第一次的连接失效了,不会理会, 让服务端浪费很多资源)

经过一顿查找, 终于拿到了服务器IP, 下一步就是连接到该服务器, 客户端与服务器的TCP连接, 就到了老生常谈的**三次握手**

### 首先, 判断是不是HTTPS, 如果是, 则HTTPS其实是HTTP+SSL/TLS两部分组成, 也就是在HTTP上又加了一层处理加密信息模块, .服务端和客户端的信息传输都会通过TLS进行加密, 所有传输的数据都是加密后的数据

#### 第一次握手 (两端都处于CLOSED状态)

- 浏览器发起连接请求报文段, SYN和Seq, 客户端将标志位SYN(Synchronization同步)置为1 , 然后生成Seq(Sequence序列) = X , 将该数据包发送给Server, 客户端进入SYN-SENT状态,等待Server确认

#### 第二次握手

- Server收到数据包后由标志位`SYN=1`得知客户端请求建立连接,Server 将标志位 SYN 和 ACK 都置为 1, Server会回送SYN和ACK(Acknowlegment(答复)) 将ACK加1, 随机产生一个值`seq=y`  给客户端以确认请求,

#### 第三次握手

- 客户端收到确认后, 会把seq设置为服务端发送过来 的ACK , 将客户端的ACK设置为服务端发送过来的seq+1,  然后向服务器发送ACK报文段, 两端都进入ESTABLISHED状态, 完成TCP三次握手

> 备注: 
>
> ACK: 此标志表示应答域有效, 有两个取值: 0 和 1 为1的时候表示应答域有效, 反之为0. TCP协议规定, 只有ACK=1时有效, 也规定连接建立后所有发送的报文的ACK必须为1
>
> SYN: 在建立连接时用来同步序号, 当SYN=1 而ACK =0时, 表示这是一个连接请求报文, 对方若同意建立连接 则应在响应报文中使SYN=1 和 ACK= 1, 因此, SYN置为1 就表示这是一个连接请求或者连接接受报文.

### 三. 发送HTTP请求

TCP连接建立后, 浏览器就可以利用http/https协议向服务器发送请求了, 一个请求报文由`请求行`,`请求头`, `空行` ,`请求体`(get请求没有请求体)组成 

### 四. 返回HTTP响应

服务器接受并处理完请求, 返回HTTP响应, 一个响应报文格式基本等同于请求报文, 由相应行, 响应头, 空行, 实体组成.

### 五. 关闭TCP连接

网络避免服务器与客户端双方的资源占用和损耗, 当双方没有请求或响应传递时, 任意一方都可以发起关闭请求. 与创建TCP连接的三次握手类似, 关闭TCP连接, 需要4次挥手

#### 第一次挥手

- 客户端设置ACK, 生成一个序号Seq 向服务端发送一个FIN报文段, 此时客户端处于FIN_WAIT_1状态, 表示客户端没有数据要发送到服务端了

#### 第二次挥手

- 服务端收到客户端发送的FIN报文段, 向客户端会送一个ACK报文段, 设置ack= 客户端发送过来的Seq + 1, seq设置为客户端发送过来的ack, 客户端进入FIN_WAIT_2状态, 服务端告诉客户端, 我同意你的关闭请求

#### 第三次挥手

- 服务端继续向客户端发送FIN报文段, 请求关闭连接, (两次发送之间传递服务器未传输完的数据)
- 服务端处于LAST_ACK状态

#### 第四次挥手

- 客户端收到服务端的FIN报文段, 向服务端发送ACK报文段,然后客户端进入TIME_WAIT状态, 服务端收到主机端的ACK报文段之后, 就关闭连接, 此时,客户端等待两个MSL后, 依然没有收到回复, 则证明服务端正常关闭, 那客户端也关闭连接

### 六.浏览器渲染

浏览器需要加载解析的不仅仅是HTML, 还包括CSS,JS, 以及还要加载图片, 视频等其他媒体资源

按照渲染的时间顺序, 流水线可分为如下几个子阶段: 构建DOM树, 样式计算, 布局阶段, 分层, 栅格化和显示

浏览器通过解析HTML, 生成DOM树, 解析CSS, 生成CSS规则树, 然后通过DOM树和CSS规则树生成渲染树, 渲染树与DOM树不同, 渲染树中没有display为none能不必显示的节点

- 构建DOM树

  - **当浏览器接收到服务器相应来的HTML文档后, 会遍历文档节点, 生成DOM树**, 先将HTML的原始字节数据转换为文件指定编码的字符, 然后浏览器会根据HTML规范来将字符串转换成各种令牌标签, 如html,body等, 最终解析成一个树状的对象模型, 就是DOM树

  - > 具体步骤：
    >
    > 1. 转码（Bytes -> Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串
    > 2. Tokens 化（Characters -> Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则
    > 3. 构建 Nodes（Tokens -> Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）
    > 4. 构建 DOM 树（Nodes -> DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系
    >
    >
    > 作者：winty
    > 链接：https://juejin.im/post/5e32449d6fb9a02fe4581907
    > 来源：掘金
    > 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

  - 需要注意的是, **DOM树的生成过程可能会被CSS和JS的加载执行阻塞**

    

- 构建CSSOM规则树

  - 浏览器解析CSS文件并生成CSS规则树, 每个CSS文件都被分析成一个StyleSheet对象, 每个对象都会包含CSS规则, CSS规则对象包含对应CSS语法的选择器和声明对象以及其他对象

  - ```javascript
    body:{font-size:2em}			body:{font-size:32px}
    p:{color:blue}					p:{color:rgba(0,0,255)}
    span:{display:none}				span:{display:none}
    div:{font-weight:blod}			div:{font-weight:700}
    ```

    可以看到CSS文本中由很多语义化的属性值, 这些类型数值不容易被渲染引擎理解, 所以需要将所有的值转换为渲染引擎容易理解的, 标准化的计算值, 这个过程就是属性值标准化, 处理完成后再处理样式的继承和层叠

- 渲染阻塞

  - 当浏览器遇到一个script标记时, DOM构建将暂停, 直到脚本完成执行, 然后继续构建DOM,每次去执行JavaScript脚本都会严重地阻塞DOM树的构建, 如果JavaScript脚本还操作了CSSOM, 而正好这个CSSOM还没有下载和构建, 浏览器甚至会延迟执行脚本和构建DOM, 直至完成其CSSOM的下载和构建
  - 所以 script的位置很重要, 实际使用时, 可以遵循下面两个原则
    - CSS优先: 引入顺序上, CSS资源先于JavaScript资源
    - JS置后: 我们通常把JS代码放到页面底部, 且JavaScript应尽量少影响DOM的构建

- 构建渲染树

  - 通过DOM树和CSS规则我们便可以构建渲染树, 浏览器会先从DOM树的根节点开始遍历每个可见节点, 对每个可见节点, 找到其适配的CSS样式规则并应用
  - 渲染树构建完成后, 每个节点都是可见节点并且都含有其内容和对应规则的样式, 这也是渲染树与DOM树的最大区别所在. **渲染树是用于显示, 那么不可见的元素当然就不会出现在这棵树里, 比如, display为none的就不会显示再这棵树里, 但是visibility为hidden的元素是会显示再这棵树的**

- 渲染树布局

  - 布局阶段会从渲染树的根节点开始遍历, 然后确定每个节点对象再页面上的确切大小与位置, 布局阶段的输出是一个盒子模型, 它会精确地捕获每个元素再屏幕内地确切位置与大小

- 渲染树绘制

  - 在绘制阶段, 遍历渲染树, 调用渲染器的paint()方法在屏幕上显示其内容, 渲染树的绘制工作是由浏览器的UI后端组件完成

- 重绘与回流

  - **根据渲染树布局, 计算CSS样式, 即每个节点在页面中的大小和位置等几何信息, HTML默认是流式布局的, CSS和JS会打破这种布局, 改变DOM的外观样式以及大小和位置**
  - **display为none 会触发重绘**
  - **visibility为hidden属性并不算是不可见属性, 它的语义是隐藏元素, 但元素仍然占据着布局空间, 它会被渲染成一个空框, 所以visibility:hidden只会触发重绘, 因为没有发生位置变化**
  - **有些情况下, 比如修改了元素的样式, 浏览器并不会立刻reflow或者repaint一次, 而是会把这样的操作积攒一批 , 然后做一次reflow, 这又叫异步reflow或者增量异步reflow**
  - **有些情况下, 比如resize窗口, 改变了页面默认的字体等, 对于这些操作, 浏览器会马上进行reflow**



















